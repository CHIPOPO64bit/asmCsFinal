#include <stdio.h>
#include "modulo.h"
#include "rsa.h"
#define _PUBLIC_KEY_FILE_OPEN "The two streams below are N and e. from left \
to right you can find the digits in hex\n\n"

#define _PRIVATE_KEY_FILE_OPEN "The stream below is d. from left \
to right you can find the digits in hex\n\n"

#define _OPEN_MSG "Welcome to encryption decryption editor.\nFor generating \
keys, press 'g'.\nFor encryption via an existing key, press 'e'.\nFor \
decryption via an existing key, press 'd'.\nFor a brief description press \
'b'.\nFor exit, press 'q'.\nPlease Enter g/e/d/b/q: "

#define _QUIT_MESSAGE "Hope you enjoyed the editor."
#define _USAGE_ERROR "USAGE: <g for keys, e for encryption, d for \
decryption, b for brief description>\n"

#define _DESCRIPTION_MSG "This is the encryption decryption big brother.\nWe \
use RSA (miller rabin variation) in order to ensure your privacy.\nBe ware, \
generation of \
primes is not an easy task and might take a couple of minuets.\n"

#define _ENTER_DECRYPTION_MESSAGE "Enter the path for the decryption key. \
Note, \
this file must have \
been generated by the editor, or, at least be in the same format, \
otherwise it won't work: "
#define _ENTER_ENCRYPTION_MSG "Enter the path for the encryption key. Note, \
this file must have \
been generated by the editor, or, at least be in the same format, \
otherwise it won't work: "

#define _DATA_FILE_MESSAGE "Please enter path for the data file"
#define _SAVE_FILE_MESSAGE "Please enter the path for the encrypted file"
#define _ENCRYPTED_FILE "Please enter path for the encrypted file"
#define _DECRYPTED_FILE "Please enter the path for the decrypted file"

#define _GENERATE_KEYS 'g'
#define _ENCRYPT_CHAR 'e'
#define _DECRYPT_CHAR 'd'
#define _BRIEF_DESC 'b'
#define _QUIT_CHAR 'q'
#define _MAX_PATH_SIZE 100
#define _MAX_LINE_LENGTH 200

/**
 * get path from user and store the result in path
 */
void get_path(char *path) {
  char cur, i = 0;
  path[(int)i] = '\0';
  cur = fgetc(stdin);
  while (cur != '\n' && i < _MAX_PATH_SIZE - 1) {
	path[(int)i] = cur;
	cur = fgetc(stdin);
	++i;
  }
  path[(int)i] = '\0';
}

/**
 * write key to file
 */
void _write_key(FILE *file, const Number *key) {
  for (int i = 0; i < key->_length; ++i) {
	fprintf(file, "%02x ", (unsigned char)key->_ptr[i]);
  }
  fprintf(file, "\n\n");
}

/**
 * write public key to file
 */
void _write_public_key(FILE *file, const Number *N, const Number *e) {
  fprintf(file, _PUBLIC_KEY_FILE_OPEN);
  _write_key(file, N);
  _write_key(file, e);
}

/**
 * write private key to file
 */
void _write_private_key(FILE *file, const Number *N, const Number *d) {
  fprintf(file, _PRIVATE_KEY_FILE_OPEN);
  _write_key(file, N);
  _write_key(file, d);
}

/**
 * handler generate keys request
 */
void _handle_generate_keys() {
  char path_public[_MAX_PATH_SIZE], path_private[_MAX_PATH_SIZE];
  // get path for
  printf("Enter the path for the public key: ");
  get_path(path_public);
  printf("Enter the path for the private key: ");
  get_path(path_private);
  FILE *public;
  FILE *private;
  public = fopen(path_public, "w");
  if (public == NULL) {
	fprintf(stderr, "Wrong path for public key.\n");
	exit(EXIT_FAILURE);
  }
  private = fopen(path_private, "w");
  if (private == NULL) {
	fclose(public);
	fprintf(stderr, "Wrong path for private key.\n");
	exit(EXIT_FAILURE);
  }
  Number e, d, N;
  Init(&e), Init(&d), Init(&N);
  _generate_keys(16, &N, &e, &d);
  _write_public_key(public, &N, &e);
  _write_private_key(private, &N, &d);
  fclose(public);
  fclose(private);
}

/**
 * convert character to integer representation
 */
char convert_to_value(char value) {
  if (value >= 'a') {
	return 10 + (value % 'a');
  }
  return value - 48;
}

/**
 * read key from line and store the result in key
 */
void _read_key(const char *line, Number *key) {

  int i = 0, j = 0;
  unsigned char ah, al, cur;
  while (line[i] && line[i] != '\n' && i < _MAX_LINE_LENGTH) {
	ah = line[i++];
	al = line[i++];
	++i;
	ah = convert_to_value(ah);
	al = convert_to_value(al);
	cur = (ah << 4) | al;

	key->_ptr[j] = cur;
	key->_length = ++j;
  }
}

/**
 * read encryption file (keys) and store the result N and e
 */
void _read_encryption_file(FILE *key_file, Number *N, Number *e) {
  char line[_MAX_LINE_LENGTH];
  fgets(line, _MAX_LINE_LENGTH, key_file);
  fgets(line, _MAX_LINE_LENGTH, key_file);
  fgets(line, _MAX_LINE_LENGTH, key_file);
  _read_key(line, N);
  fgets(line, _MAX_LINE_LENGTH, key_file);
  fgets(line, _MAX_LINE_LENGTH, key_file);
  _read_key(line, e);
}

/**
 * open file and check validation
 * @return 0 if failed, 1 otherwise
 */
int _open_file(FILE **file, const char *msg, const char *mode) {
  char path[_MAX_PATH_SIZE];
  printf("%s\n", msg);
  get_path(path);
  *file = fopen(path, mode);
  if (*file == NULL) {
	fprintf(stderr, "Error, file doesn't exists\n");
	return 0;
  }
  return 1;
}

/**
 * write data to file
 */
void _write_data(FILE *file, const Number *data) {
  for (int i = 0; i < data->_length; ++i) {
	fprintf(file, "%02x", data->_ptr[i]);
  }
}

/**
 * write encrypted data
 */
void _write_decrypted(FILE *file, const Number *data) {
  for (int i = 0; i < data->_length; ++i) {
	fprintf(file, "%c", data->_ptr[i]);
  }
}

/**
 * encrypt data and write the result to ecnrypted file
 * @param N modulus
 * @param e power
 */
void _encrypt(FILE *data, FILE *encrypted, const Number *N, const Number *e) {
  Number temp, res;
  Init(&res);
  char line[_MAX_STRING + 1];
  int i, length;
  while ((length = fread(line, sizeof(char), _MAX_STRING, data))) {
	i = 0;
	line[length] = '\0';

	Init(&temp);
	while (i < length) {
	  temp._ptr[i] = line[i];
	  temp._length = ++i;
	}
	Init(&res);
	_modular_exp(&temp, e, N, &res);
	for (int i = res._length; i < _MAX_SEGMENT; ++i) {
	  res._ptr[i] = 0;
	}
	res._length = _MAX_SEGMENT;
	_write_data(encrypted, &res);

  }
}

/**
 * handle encrypt request
 */
void _handle_encrypt() {
  Number N, e;
  Init(&N), Init(&e);
  FILE *key_file, *data_file, *encrypted_file;
  if (!_open_file(&key_file, _ENTER_ENCRYPTION_MSG, "r")) {
	exit(EXIT_FAILURE);
  } else if (!_open_file(&data_file, _DATA_FILE_MESSAGE,
						 "r")) {
	fclose(key_file);
	exit(EXIT_FAILURE);
  } else if (!_open_file(&encrypted_file, _SAVE_FILE_MESSAGE, "w")) {
	fclose(key_file);
	fclose(data_file);
  }
  _read_encryption_file(key_file, &N, &e);
  _encrypt(data_file, encrypted_file, &N, &e);
  fclose(key_file);
  fclose(data_file);
  fclose(encrypted_file);
}

/**
 * decrypt encrypted file and write result to decrypted file
 * @param N modulus
 * @param d power
 */
void _decrypt(FILE *encrypted, FILE *decrypted, const Number *N, const Number
*d) {
  Number temp, res;
  Init(&res);
  char line[2 * _MAX_SEGMENT], ah, al;
  int i, length, j;
  while ((length = fread(line, sizeof(char),
						 _MAX_SEGMENT * 2,
						 encrypted))) {
	i = 0, j = 0;
	line[length] = '\0';
	Init(&temp);
	while (i < length) {
	  ah = convert_to_value(line[i++]);
	  al = convert_to_value(line[i++]);
	  temp._ptr[j] = al | ah << 4;
	  if (temp._ptr[j] != 0) {
		temp._length = j + 1;
	  }
	  ++j;
	}
	Init(&res);
	_modular_exp(&temp, d, N, &res);
	_write_decrypted(decrypted, &res);
  }
}

/**
 * handle decrypt request
 */
void _handle_decrypt() {
  Number d, N;
  Init(&d), Init(&N);
  FILE *key_file, *encrypted_file, *decrypted_file;
  if (!_open_file(&key_file, _ENTER_DECRYPTION_MESSAGE , "r")) {
	exit(EXIT_FAILURE);
  } else if (!_open_file(&encrypted_file, _ENCRYPTED_FILE,
						 "r")) {
	fclose(key_file);
	exit(EXIT_FAILURE);
  } else if (!_open_file(&decrypted_file, _DECRYPTED_FILE, "w")) {
	fclose(key_file);
	fclose(encrypted_file);
	exit(EXIT_FAILURE);
  }
  _read_encryption_file(key_file, &N, &d);
  _decrypt(encrypted_file, decrypted_file, &N, &d);
  fclose(key_file);
  fclose(decrypted_file);
  fclose(encrypted_file);
}

/**
 * handle description request
 */
void _handle_description() {
  printf("%s\n", _DESCRIPTION_MSG);
}

/**
 * request handler
 * @param ctrl
 */
void _handle_request(const char ctrl) {

  init_program();
  if (ctrl == _GENERATE_KEYS) {
	_handle_generate_keys();
  } else if (ctrl == _ENCRYPT_CHAR) {
	_handle_encrypt();
  } else if (ctrl == _DECRYPT_CHAR) {
	_handle_decrypt();
  } else if (ctrl == _BRIEF_DESC) {
	_handle_description();
  } else if (ctrl == _QUIT_CHAR) {
	printf("%s\n", _QUIT_MESSAGE);
  } else {
	printf("%s\n", _USAGE_ERROR);
  }
}

int main() {
  char ctrl;
  do {
	printf("%s\n", _OPEN_MSG);
	ctrl = fgetc(stdin);
	fgetc(stdin);
	_handle_request(ctrl);
  } while (ctrl != 'q');
  return 0;
}
