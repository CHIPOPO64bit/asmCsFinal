
; The following file was generated by an external converter written by David 
; Keisar Schmidt, by using Regex
; All rights reserved



IDEAL
MODEL small
STACK 100h

DATASEG

; headers
; #include "modulo.h"

; macros

; Docs
; init number
; @param _ptr number pointer
; @Complexity O(log(n))
 
; void Init(Number *_ptr)
proc Init
	pusha
	popa
endp Init

; Docs
; prints _ptr
; @param _ptr number pointer
; @Complexity O(log(n))
 
; void _print_number(const Number *_ptr)
proc _print_number
	pusha
	popa
endp _print_number

; Docs
; @return max(a,b)
 
; int _max(int a, int b)
proc _max
	pusha
	popa
endp _max

; Docs
; @return min(a,b)
 
; int _min(int a, int b)
proc _min
	pusha
	popa
endp _min

; Docs
; addition of two Numbers
; @param _byte_shift shift rhs <> bytes
; @param _bit_shift shift rhs <> bits
; @Complexity: O(log(n))
 
; void _add(const Number *_lhs, const Number *_rhs, Number *_res, int_byte_shift, int _bit_shift)
proc _add
	pusha
	popa
endp _add

; Docs
; computes -number
; @param _ptr number
; @param _res stores the result in _res
; @Complexity O(log(n))
 
; void _neg(const Number *_ptr, Number *_res)
proc _neg
	pusha
	popa
endp _neg

; Docs
; subtraction _lhs - _rhs
; @param _res stores the result in _res
; @Complexity O(log(n))
 
; void _sub(const Number *_lhs, const Number *_rhs, Number *_res, int bytes,  int bits)
proc _sub
	pusha
	popa
endp _sub

; Docs
; copy _rhs into _lhs by value
; @Complexity O(log(n))
 
; void _copy(Number *_lhs, const Number *_rhs)
proc _copy
	pusha
	popa
endp _copy

; Docs
; @return _lhs > _rhs
; @Complexity O(log(n))
 
; int gt(const Number *_lhs, const Number *_rhs)
proc gt
	pusha
	popa
endp gt

; Docs
; @return _lhs >= _rhs
; @Complexity O(log(n))
 
; int ge(const Number *_lhs, const Number *_rhs)
proc ge
	pusha
	popa
endp ge

; Docs
; ==
; @return 1 if equal 0 otherwise
 
; int eq(const Number *_lhs, const Number *_rhs)
proc eq
	pusha
	popa
endp eq

; Docs
; Helper method for divide, computes the quotient in _res
; A greedy method.
; @param _q_y helper variable
; @param _res quotient
; @Complexity O(log(n^2))
 
; void _div_helper(const Number *_lhs, const Number *_rhs, Number *restrict _q_y, Number *_res)
proc _div_helper
	pusha
	popa
endp _div_helper

; Docs
; Modulo of two numbers _lhs mod _rhs. stored in _res
; @Complexity: O(log^2(n))
 
; void _modulo(const Number *_lhs, const Number *_rhs, Number *_res)
proc _modulo
	pusha
	popa
endp _modulo

; Docs
; find the msb bit of an integer
; @return the msb index
; @Complexity O(log(n))
 
; int _find_msb(uint8_t a)
proc _find_msb
	pusha
	popa
endp _find_msb

; Docs
; The modular exponentiation (_exp_base)**(_exp) mod _base. Stored in _res
; @Comlexitiy O(log^3(n))
 
; void _modular_exp(const Number  *_exp_base, const Number *_exp, const Number *_base, Number  *_res)
proc _modular_exp
	pusha
	popa
endp _modular_exp

; Docs
; shift right
; @param _ptr number to shift
; @param _bits_shift 0-8
; @Complexity: O(log(n))
 
; void _shift_right(const Number *_ptr, Number *_res, int _bytes_shift, int_bits_shift)
proc _shift_right
	pusha
	popa
endp _shift_right

; Docs
; Compose a number to the form (u*2^s) where u is odd
; @param _ptr base
; @param _u odd
; @param _exp power
; @Complexity O(log(n))
 
; void _compose(const Number *_ptr, Number *_u, Number *_exp, int *_pow)
proc _compose
	pusha
	popa
endp _compose

; Docs
; Find s,t such that a*s+b*t=gcd(a,b), assume _a > _b
; @Complexity O(log^3(n))
 
; void _extended_euclid(const Number *_a, const Number *_b, Number *_gcd, Number*_s, Number *_t)
proc _extended_euclid
	pusha
	popa
endp _extended_euclid

; Docs
; Find the multiplicative inverse of _ptr mod _base
; @param _prt number to find its inverse
; @param _res result stored in _res
; @param _base modulo base
; @Complexity O(log^3(n))
 
; void _inverse(const Number *_ptr, const Number *_base, Number *_res)
proc _inverse
	pusha
	popa
endp _inverse

; Docs
; generate a random number in the range 1,...,_upper_bound - 1
; @param _upper_bound range upper bound
; @param _res the result is stored in _res
 
; void _random(const Number *_upper_bound, Number *_res)
proc _random
	pusha
	popa
endp _random


start:
    mov ax, @data
    mov ds, ax
    
exit:
    mov ax, 4c00h
    int 21h
END start
