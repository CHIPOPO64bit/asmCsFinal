
; The following file was generated by an external converter written by David 
; Keisar Schmidt, by using Regex
; All rights reserved



.286
IDEAL
MODEL small
STACK 9999h

DATASEG

; headers
; #include <stdint.h>
; #include <stdio.h>
; #include <stdlib.h>
; #include <time.h>

; macros
_DEFAULT_SIZE equ 36d
_EFFECTIVE_SIZE equ 35d
_MAX_STRING equ 31d
_MAX_SEGMENT equ 32d
_CARRY_MASK equ 255d
_CARRY_MASK_LENGTH equ 8d
_BASE_UNIT equ 8d
_zero db _DEFAULT_SIZE dup(0)
_one db _DEFAULT_SIZE dup(1)
_arr db _DEFAULT_SIZE dup(255); 6d, 255, 255, 255, 255, 255, 255,0
_brr db _DEFAULT_SIZE dup(0); 6d, 255, 255, 255, 255, 255, 255,0
_crr db _DEFAULT_SIZE dup(0)
arg1 equ [word ptr bp+4]
arg2 equ [word ptr bp+6]
arg3 equ [word ptr bp+8]
arg4 equ [word ptr bp+10]
arg5 equ [word ptr bp+12]
lcl1 equ [word ptr bp-2]
lcl2 equ [word ptr bp-4]
lcl3 equ [word ptr bp-6]
lcl4 equ [word ptr bp-8]
lcl5 equ [word ptr bp-10]
lcl6 equ [word ptr bp-12]
lcl7 equ [word ptr bp-14]
lcl8 equ [word ptr bp-16]
lcl9 equ [word ptr bp-18]
lcl10 equ [word ptr bp-20]

; macros for _add
_lhs equ [word ptr bp+4]
_rhs equ [word ptr bp+6]
_res equ [word ptr bp+8]
_byte_shift equ [word ptr bp+10]
_bit_shift equ [word ptr bp+12]

_lhs_copied equ [word ptr bp - 2]
_rhs_copied equ [word ptr bp - 4]
_carry equ [word ptr bp - 6]
_temp equ [word ptr bp - 8]
_max_length equ [word ptr bp - 10]
_res_ptr equ [word ptr bp - 12]
_idx equ [word ptr bp - 16]

CODESEG

; Docs
; * init number
; * @param _ptr number pointer
; * @Complexity O(log(n))
; void Init(Number *_ptr)
proc Init
	; init regs
	push bp
	mov bp, sp
	push offset _zero
	push arg1
	call _copy
	pop bp
	ret 2d
endp Init

; print char
proc _print_char
	push bp
	mov bp, sp
	push ax
	push dx
	mov dx, arg1
	mov ah, 02h
	int 21h
	pop dx
	pop ax
	pop bp
	ret 2d
endp _print_char

; print digit (base 10)
proc _print_digit
	push bp
	mov bp, sp
	; save regs
	push cx
	push dx
	push ax
	push bx
	; save arg
	xor ax, ax
	mov ax, arg1
	xor cx, cx
	xor dx, dx
	; find all digits
	_find_digits:
		mov bx, 10d
		; compute the current digit (arg1 mod 10)
		div bx
		; arg1 mod 10
		push dx
		; increment counter
		inc cx
		; init dx
		xor dx, dx
		; check if we found all digits
		cmp ax, 0
		jne _find_digits

	_print_digits:
		; store current value to dx
		pop dx
		; make digit
		add dx, 48d
		; print character
		mov ah, 02h
		int 21h
		cmp cx, 0
		dec cx
		jne _print_digits
	; print space
	mov dx, 32d
	mov ah, 02h
	int 21h
	; restore regs
	pop bx
	pop ax
	pop dx
	pop cx
	pop bp
	ret 2d
endp _print_digit
; Docs
; * prints _ptr
; * @param _ptr number pointer
; * @Complexity O(log(n))
; void _print_number(const Number *_ptr)
proc _print_number
	push bp
	mov bp, sp
	push cx
	push ax
	push si
	; init regs
	xor cx, cx
	xor ax, ax
	xor si, si
	; set si to point to array and store size in ax
	mov si, arg1
	xor ah, ah
	mov al, [si]
	; set si to last digit (msb)
	add si, ax ; add length, last digit
	; set counter to array size
	mov cx, ax

	; print digits
	dig:
		xor ah, ah
		mov al, [si]
		push ax
		call _print_digit
		dec si
	loop dig
	push 10d; \n
	call _print_char
	pop si
	pop ax
	pop cx
	pop bp
	ret 2d
endp _print_number

; Docs
; * @return max(a,b) in ax
; int _max(int a, int b)
proc _max
	push bp
	mov bp, sp
	push bx
	mov ax, arg1
	mov bx, arg2
	cmp ax, bx
	JB max_is_bx
	jmp _max_end
	max_is_bx:
		mov ax, bx
		jmp _max_end
	_max_end:
	pop bx
	pop bp
	ret 4d
endp _max

; Docs
; * @return min(a,b) in ax
; int _min(unsgined int a, unsigned int b)
proc _min
	push bp
	mov bp, sp
	push bx
	mov ax, arg1
	mov bx, arg2
	cmp ax, bx
	JA min_is_bx
	jmp _min_end
	min_is_bx:
		mov ax, bx
		jmp _min_end
	_min_end:
	pop bx
	pop bp
	ret 4d
endp _min

; Docs
; * addition of two Numbers
; * @param _byte_shift shift rhs <> bytes
; * @param _bit_shift shift rhs <> bits
; * @Complexity: O(log(n))
; void _add(const Number *_lhs, const Number *_rhs, Number *_res, int_byte_shift, int _bit_shift)
proc _add ; change code to db instead of dw

	push bp
	mov bp, sp
	
	sub sp, 20
	; allocate _rhs_copied and _lhs_copied
	sub sp, _DEFAULT_SIZE
	mov _lhs_copied, sp
	sub sp, _DEFAULT_SIZE
	mov _rhs_copied, sp
	; save regs
	push di
	push si
	push bx
	push ax
	; copy rhs to rhs_copied and lhs_copied to lhs
	; lhs
	push _lhs 
	push _lhs_copied
	call _copy
	; rhs
	push _rhs
	push _rhs_copied
	call _copy

	mov _carry, 0
	mov _temp, 0
	mov _max_length, 0
	mov si, _lhs_copied
	mov di, _rhs_copied
	; compute max (rhs length +byte_shift,lhs length)
	mov al, [si]
	xor ah, ah
	push ax
	mov al, [di]
	add ax, _byte_shift
	push ax
	call _max
	; compute min (prev, DEFAULT_SIZE)
	push ax
	push _effective_size
	call _min
	; loop counter
	mov cx, ax 
	mov _max_length, ax
	; init _res
	push _res
	pop _res_ptr
	push _res_ptr
	call Init
	; set res length to be max length
	mov ax, _max_length
	; set si to be res
	push si
	mov si, _res_ptr
	mov [si], al
	pop si
	; i = 0
	mov _idx, 0
	; these next lines add the two numbers
	; set them to first digit
	mov al, [di]
	xor ah, ah
	push ax
	call _print_digit
	inc si
	inc di
	inc _res_ptr
	add_digits:
		
		mov ax, _idx
		cmp ax, _byte_shift
		JAE no_zero_padded_case
			; padding
			; move clear ptr_l[i] to temp
			mov al, [si]
			xor ah, ah
			mov _temp, ax
		jmp end_padding_case
		no_zero_padded_case:
			mov al, [si]
			xor ah, ah
			mov _temp, ax
			sub di, _byte_shift
			mov bl, [di]
			xor bh, bh
	
			add di, _byte_shift
			
			; temp += ptr_r[i - _byte_shift] << _bit_shift
			push cx ; save cx value
			mov cx, _bit_shift
			shl bx, cl
			pop cx
			
			add _temp, bx
			
			
			; temp += carry
			mov bx, _carry
			add _temp, bx
		end_padding_case:
			; ptr_res[i] = (8 lsb bits) temp
			push si
			mov si, _res_ptr ; si stores res
			mov ax, _temp
			mov [si], al ; 8 lsb bits
			pop si ; si stores lhs
			; carry stores overflowed bits
			mov al, ah
			xor ah, ah
			mov _carry, ax ; 8 lsb bits
			; move one digit forwards
			inc di
			inc si
			inc _res_ptr
			inc _idx
	loop add_digits
			push 10d
			call _print_char
			push 10d
			call _print_char
	mov ax, _max_length
	; take care of overflow 
	; push 97d
	; call _print_char

	cmp ax, _effective_size
	JAE free_regs_add
	cmp _carry, 0d
	JE free_regs_add
	mov si, _res
	; set length of res to max length + 1
	mov ax, _max_length
	inc ax
	mov [si], al
	; set last digit to be carry
	add si, _max_length
	inc si
	mov ax, _carry
	mov [si], al

	free_regs_add:
	; deallocate them
	pop ax
	pop bx
	pop si
	pop di
	add sp, _DEFAULT_SIZE
	add sp, _DEFAULT_SIZE
	add sp, 20

	; restore regs

	pop bp
	ret 10d
endp _add

; Docs
; * computes -number
; * @param _ptr number
; * @param _res stores the result in _res
; * @Complexity O(log(n))
; void _neg(const Number *_ptr, Number *_res)
proc _neg
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _neg

; Docs
; * subtraction _lhs - _rhs
; * @param _res stores the result in _res
; * @Complexity O(log(n))
; void _sub(const Number *_lhs, const Number *_rhs, Number *_res, int bytes,  int bits)
proc _sub
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _sub

; Docs
; * copy _rhs into _lhs by value
; * @Complexity O(log(n))
; void _copy(Number *_lhs, const Number *_rhs)
proc _copy
	; init regs
	push bp
	mov bp, sp
	push si
	push di
	push cx
	push bx
	push ax

	xor cx, cx
	xor si, si
	xor di, di
	xor bx, bx
	xor ax, ax
	
	; copy args into arg1
	mov cx, _DEFAULT_SIZE
	mov si, arg1
	mov di, arg2
	move_from:
		mov bl, [di]
		mov [si], bl
		mov al, [si]
		inc si
		inc di
	loop move_from
	; restore regs
	pop ax
	pop bx
	pop cx
	pop di
	pop si
	pop bp
	ret 4d
endp _copy

; Docs
; * @return _lhs > _rhs
; * @Complexity O(log(n))
; int _gt(const Number *_lhs, const Number *_rhs)
proc _gt
	; init
	push bp
	mov bp, sp
	push bx
	push si
	push di
	push cx
	xor ax, ax
	xor bx, bx
	; store addresses in regs
	mov si, arg1
	mov di, arg2
	; compare lengths
	mov al, [si]
	mov bl, [di]
	cmp al, bl
	JA _lhs_bigger_than_rhs
	JB _rhs_bigger_than_lhs
	
	mov cx, ax
	; set si and di to last digit
	add si, ax
	add di, ax
	
	radix_compare:
		mov al, [si]
		mov bl, [di]
		cmp al, bl
		JA _lhs_bigger_than_rhs
		JB _rhs_bigger_than_lhs
		dec si
		dec di
	loop radix_compare
	xor ax, ax ; equal
	jmp end_gt
	_lhs_bigger_than_rhs:
		xor ax, ax
		mov ax, 1d ; true
		jmp end_gt
	_rhs_bigger_than_lhs:
		xor ax, ax ; false
	; restore regs
	end_gt:
	pop cx
	pop di
	pop si
	pop bx
	pop bp
	ret 4d
endp _gt

; Docs
; * @return _lhs >= _rhs
; * @Complexity O(log(n))
; int ge(const Number *_lhs, const Number *_rhs)
 proc _ge
	push bp
	mov bp, sp
	; _lhs >= _rhs iff !(_rhs > _lhs)
	push arg1
	push arg2
	call _gt
	xor ax, 1d ; toggle result
	pop bp
	ret 4d
endp _ge

; Docs
; * ==
; * @return 1 if equal 0 otherwise
; int eq(const Number *_lhs, const Number *_rhs)
proc _eq
	; init
	push bp
	mov bp, sp
	push bx
	push si
	push di
	push cx
	xor cx, cx
	; store addresses in regs
	mov si, arg1
	mov di, arg2
	mov cl, [si]
	inc cx ; compare lengths at first
	
	compare_bytes: ; compare current digit / length
		mov al, [si]
		mov bl, [di]
		cmp al, bl
		JNE _different_numbers
		inc si
		inc di
		xor ax, ax
	loop compare_bytes
	mov ax, 1d
	jmp end_eq
	_different_numbers:
		xor ax, ax ; false
	; restore regs
	end_eq:
	pop cx
	pop di
	pop si
	pop bx
	pop bp
	ret 4d
endp _eq

; Docs; void _mult(const Number *_lhs, const Number *_rhs, Number *restrict _res)
proc _mult
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _mult

; Docs
; * helper method for divide, computes the quotient in _res
; * @param _q_y helper variable
; * @param _res quotient
; * @Complexity O(log(n^2))
; void _div_helper(const Number *_lhs, const Number *_rhs, Number *_q_y, Number *_res)
proc _div_helper
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _div_helper

; Docs; void _div(const Number *_lhs, const Number *_rhs, Number *_res)
proc _div
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _div

; Docs
; * Modulo of two numbers _lhs mod _rhs. stored in _res
; * @Complexity: O(log^2(n))
; void _modulo(const Number *_lhs, const Number *_rhs, Number *_res)
proc _modulo
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _modulo

; Docs
; * find the msb bit of an integer
; * @return the msb index
; * @Complexity O(log(n))
; int _find_msb(uint8_t a)
proc _find_msb
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _find_msb

; Docs
; * The modular exponentiation (_exp_base)**(_exp) mod _base. Stored in _res
; * @Comlexitiy O(log^3(n))
; void _modular_exp(const Number *_exp_base, const Number *_exp, const Number*_base, Number *_res)
proc _modular_exp
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _modular_exp

; Docs
; * shift right
; * @param _ptr number to shift
; * @param _bits_shift 0-8
; * @Complexity: O(log(n))
; void _shift_right(const Number *_ptr, Number *_res, int _bytes_shift, int_bits_shift)
proc _shift_right
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _shift_right

; Docs
; * Compose a number to the form (u*2^s) where u is odd
; * @param _ptr base
; * @param _u odd
; * @param _exp power
; * @Complexity O(log(n))
; void _compose(const Number *_ptr, Number *_u, Number *_exp, int *_pow)
proc _compose
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _compose

; Docs
; * Find s,t such that a*s+b*t=gcd(a,b), assume _a > _b
; * @Complexity O(log^3(n))
; void _extended_euclid(const Number *_a, const Number *_b, Number *_gcd, Number*_s, Number *_t)
proc _extended_euclid
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _extended_euclid

; Docs
; * Find the multiplicative inverse of _ptr mod _base
; * @param _prt number to find its inverse
; * @param _res result stored in _res
; * @param _base modulo base
; * @Complexity O(log^3(n))
; void _inverse(const Number *_ptr, const Number *_base, Number *_res)
proc _inverse
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _inverse

; Docs
; * generate a random number in the range 1,...,_upper_bound - 1
; * @param _upper_bound range upper bound
; * @param _res the result is stored in _res
; void _random(const Number *_upper_bound, Number *_res)
proc _random
	pusha
	mov bp, sp
	sub sp, 8
	add sp, 8
	popa
	ret
endp _random


start:
    mov ax, @data
    mov ds, ax
	mov [_zero], _EFFECTIVE_SIZE
	push offset _zero
	call _print_number
	; push bp
	; mov bp, sp
	; sub sp, _DEFAULT_SIZE
	; mov lcl1, sp
	; push offset _arr
	; push lcl1
	; call _copy
	; push lcl1
	; call _print_number
	mov [_brr], _effective_size
	mov [byte ptr _brr + 1], 1d
	push offset _brr
	call _print_number

	mov [_arr], _effective_size
	push offset _arr
	call _print_number
	;mov [byte ptr _brr +1], 1d
	push 0d
	push 0d
	push offset _crr
	push offset _brr
	push offset _arr
	call _add
	push offset _crr
	call _print_number

	

exit:
    mov ax, 4c00h
    int 21h


END start
